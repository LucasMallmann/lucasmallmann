---
title: 'Aprimorando a Performance Web: Explorando o poder do prÃ©-carregamento com o quicklink'
publishedAt: '2023-06-27'
summary: 'Acelerando o desempenho web: como o quicklink pode ajudar vocÃª a prÃ©-carregar links, melhorar a experiÃªncia do usuÃ¡rio e carregar conteÃºdo mais rapidamente?'
image: '/static/images/boosting-web-performance-quicklink/banner.jpg'
tags: ['webperf', 'prefetch', 'programming']
lang: 'pt-BR'
---

# O que Ã© quicklink?

[Quicklink](https://github.com/GoogleChromeLabs/quicklink) Ã© uma biblioteca JavaScript que melhora os carregamentos subsequentes de pÃ¡ginas prÃ©-carregando ou prÃ©-renderizando os links que estÃ£o dentro do viewport do usuÃ¡rio.

VocÃª pode instruir o navegador a prÃ©-carregar os links desejados e, quando o usuÃ¡rio efetivamente clicar neles, a pÃ¡gina serÃ¡ carregada mais rapidamente, pois o navegador jÃ¡ terÃ¡ buscado o HTML para aquele link.

Quicklink oferece duas funcionalidades principais: `prefetching` e `preloading`. A diferenÃ§a principal entre eles Ã© que, com o prefetching, que Ã© o que veremos hoje, o navegador apenas busca o HTML do link. Com o preloading, o navegador utiliza [speculation rules](https://github.com/WICG/nav-speculation/blob/main/triggers.md) para carregar os links antecipadamente. Isso requer um pouco mais de trabalho, entÃ£o deixaremos isso para outro post. :)

## Como isso Ã© Ãºtil?

Imagine um cenÃ¡rio em que vocÃª tem um site com vÃ¡rios links
que levam o usuÃ¡rio para diferentes pÃ¡ginas. Mas vocÃª percebeu que
alguns links sÃ£o mais populares do que outros, e os usuÃ¡rios tendem a clicar neles com mais frequÃªncia.
NÃ£o faria sentido carregar esses links antecipadamente de alguma forma, para que o
usuÃ¡rio possa ter uma experiÃªncia melhor?

Claro que faria, e Ã© aÃ­ que o quicklink se torna Ãºtil.
Com essa estratÃ©gia, vocÃª pode prÃ©-carregar os links que deseja impulsionar
o desempenho do seu site e, o mais importante, melhorar a experiÃªncia do usuÃ¡rio, pois a pÃ¡gina serÃ¡
carregada mais rapidamente.

## How does this work?

In order to pretech the subsequent urls, quickinlink:

- Detects links in the viewport
- Waits until the browser is idle, using [requestIdleCallback](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback)
- Prefetches using `<link rel=prefetch>` or XHR.

## Exemplo prÃ¡tico

Configurei um blog HTML bem simples para mostrar como o quicklink funciona. VocÃª pode encontrar o cÃ³digo [aqui](https://github.com/LucasMallmann/blog-quicklink).
VocÃª pode baixar o cÃ³digo-fonte e acompanhar o tutorial, se quiser. Existe um [branch](https://github.com/LucasMallmann/blog-quicklink/tree/quicklink) que jÃ¡
possui a implementaÃ§Ã£o do quicklink, entÃ£o vocÃª pode conferir se tiver alguma dÃºvida ou se quiser ver a implementaÃ§Ã£o.

```bash
$ git clone https://github.com/LucasMallmann/blog-quicklink.git
$ cd blog-quicklink
```

Esse projeto tem uma estrutura simples, foi feito com [vitejs](https://vitejs.dev/). Se vocÃª executar o project e abri o navegador em `http://localhost:3000`, vocÃª verÃ¡ um simples blog com alguns links, como Ã© mostrado abaixo:

<Image
  alt="Vercel Analytics"
  src="/static/images/boosting-web-performance-quicklink/sample-blog.png"
  width={672}
  height={300}
/>

## Testando o desempenho de navegaÃ§Ã£o

Utilizei a guia de desempenho do Chrome para realizar esses testes. O que fiz foi clicar nessas URLs e medir quanto tempo elas levam para carregar (incluindo mÃ©tricas web vitals como FCP, LCP, TFB) com e sem o quicklink.

**ObservaÃ§Ã£o**: Realizei todos esses testes com a mesma configuraÃ§Ã£o: rede limitada para `Fast 3g`e CPU em `4x slowdown`. Isso nÃ£o Ã© obrigatÃ³rio, mas Ã© uma boa prÃ¡tica para simular um dispositivo mais lento com uma conexÃ£o de internet pior.

### Sem o quicklink

<Image
  alt="Blog without quicklink"
  src="/static/images/boosting-web-performance-quicklink/without-quicklink.gif"
  width={672}
  height={300}
  quality={100}
/>

<Image
  alt="Without quicklink performance report"
  src="/static/images/boosting-web-performance-quicklink/without-quicklink-report.png"
  width={672}
  height={300}
  quality={100}
/>

Como vocÃª pode ver, o [LCP](https://web.dev/lcp/) bateu em aprox. ~1.20s. Vamos ver como podemos melhorar isso!

## Implementando quicklink

Primeiro, vocÃª pode baixÃ¡-lo desta [fonte](https://unpkg.com/quicklink@2.3.0/dist/quicklink.umd.js), ou pode baixÃ¡-lo do [repositÃ³rio do GitHub](https://github.com/GoogleChromeLabs/quicklink) e pegar o arquivo `quicklink.umd.js`.

Copiei o arquivo e o coloquei em `public/quicklink.umd.js`. ApÃ³s isso, vocÃª pode ir para o seu arquivo principal `index.html` e carregar o script a partir do diretÃ³rio pÃºblico. VocÃª pode colocÃ¡-lo no final da tag `body`, assim:

```html
<body>
  ...
  <script async src="/quicklink.umd.js"></script>
</body>
```

Agora, precisamos informar ao quicklink quais links ele deve observar e fazer prefetch. Isso pode ser feito adicionando outra tag de script ao final da tag body novamente:

```html
<body>
  ...
  <script>
    window.addEventListener('load', () => {
      const linksToPrefetch = document.querySelectorAll('.post-list a');

      quicklink.listen({
        el: linksToPrefetch,
        limit: 10, // Limite opcional para determinar quantos links ele irÃ¡ fazer o prefetch
        delay: 0, // Quantidade de tempo (em ms) que o link precisa estar dentro do viewport do usuÃ¡rio para que seja prÃ©-carregado
      });
    });
  </script>
</body>
```

A variÃ¡vel `linksToPrefetch` contÃ©m os links que vocÃª deseja fazer prefetch, usando um HTMLSelector simples.

Agora, quando vocÃª executar o servidor de desenvolvimento novamente, poderÃ¡ ver as pÃ¡ginas do blog tambÃ©m aparecerem na [network tab](https://developer.chrome.com/docs/devtools/network/), o que indica que elas estÃ£o sendo prÃ©-carregadas.

<Image
  alt="Network calls with quicklink"
  src="/static/images/boosting-web-performance-quicklink/network-with-quicklink.png"
  width={672}
  height={300}
  quality={100}
/>

## Testando o quicklink

**Dica:** Recomendo que vocÃª execute `npm run build` e depois `npm run preview` para testar o desempenho, pois os arquivos estÃ£o comprimidos e prontos para produÃ§Ã£o, e nÃ£o no modo de desenvolvimento como em `npm run dev`.

Certo, vamos ver se nossa ideia melhorou algo ou nÃ£o! O teste Ã© o mesmo: usando a guia de _performance_, clique no botÃ£o **gravar** e navegue do arquivo principal `index.html` para um post de blog, como `post-blog-1.html`:

<Image
  alt="With quicklink performance report"
  src="/static/images/boosting-web-performance-quicklink/with-quicklink-report.png"
  width={672}
  height={300}
  quality={100}
/>

Como vocÃª pode ver, a mÃ©trica LCP passou de `1,20s` para cerca de `636ms`, o que significa que a mÃ©trica foi disparada muito mais cedo do que quando o quicklink nÃ£o estava presente. Podemos ver outras melhorias tambÃ©m, estou usando o LCP como base :)

- ğŸ“ˆ LCP de `~1.2s` para `~636ms`
- ğŸ“ˆ Load event de `~1.31s` para `~731ms`
- ğŸ“ˆ DCL de `~1.24s` para `~623ms`
- ğŸ“ˆ Rendering de `~99ms` para `~79ms`

## ConclusÃ£o

Implementar o Quicklink Ã© uma ideia fantÃ¡stica para aprimorar a velocidade de carregamento da pÃ¡gina e oferecer uma experiÃªncia de usuÃ¡rio aprimorada! Recomendo fortemente que vocÃª experimente em seus websites e avalie os benefÃ­cios em primeira mÃ£o. Ã‰ especialmente valioso medir impactos especÃ­ficos, como o carregamento mais rÃ¡pido de anÃºncios resultando em uma visualizaÃ§Ã£o aprimorada, maior engajamento do usuÃ¡rio e carregamento mais rÃ¡pido de imagens.

Espero sinceramente que vocÃª tenha achado este post do blog agradÃ¡vel. Marca minha estreia no mundo dos blogs, e estou entusiasmado com o resultado. Conforme o tempo passa, aspira entregar mais conteÃºdo valioso para vocÃª. NÃ£o hesite em entrar em contato se tiver alguma dÃºvida ou se quiser simplesmente iniciar uma conversa. Um agradecimento especial ao [Gilberto](https://twitter.com/gilberto_cocchi), que me apresentou a este tÃ³pico e forneceu assistÃªncia inestimÃ¡vel em minha jornada profissional!
